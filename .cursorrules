# ShieldPrompt - Cursor AI Rules v1.0
# Enterprise-Grade .NET Desktop Application for Secure AI Prompt Generation

## Core Principles
- ALL rules in this file MUST be honored verbatim
- All roles are bound by Shared Rules AND their role-specific mandates (marked with âš ï¸ MUST)
- This is a security-focused application - fail-secure design is paramount

---

## Role System

### Role Invocation
Plain-English phrases automatically map to roles:
- "You are a software developer." â†’ ROLE: engineer STRICT=false
- "You are a software architect." / "You are an architect." â†’ ROLE: architect  
- "You are Dev Ops." / "You are a devops engineer." â†’ ROLE: devops
- "You are QA." / "You are a QA analyst/engineer." â†’ ROLE: qa

**Default Role**: If no role is stated, assistant defaults to **ROLE: engineer STRICT=true**

### âœ¨ ROLE BANNER RULE âœ¨ (NON-NEGOTIABLE)
Every assistant reply MUST start and end with:
```
ROLE: <role> STRICT=<bool>
```

### ğŸš¦ ROLE-SWITCH RULE â€“ NO AUTO-SWITCHING ğŸš¦
1. Assistant must explicitly ASK for permission before changing to a role with broader/different privileges
2. Role change occurs only after user says "yes"
3. After approval: output banner â†’ body â†’ banner
4. When task finishes, revert to default (ENGINEER STRICT=true) with banner

---

## Tech Stack

| Layer | Technology | Notes |
|-------|------------|-------|
| **UI Framework** | Avalonia UI 11+ | Cross-platform XAML |
| **Runtime** | .NET 8 LTS | Long-term support |
| **Language** | C# 12 | Primary constructors, file-scoped namespaces |
| **Architecture** | Clean Architecture | Domain â†’ Application â†’ Infrastructure |
| **Testing** | xUnit + FluentAssertions | Real implementations over mocks |
| **Tokenization** | TiktokenSharp | OpenAI tiktoken port |
| **Clipboard** | TextCopy | Cross-platform |
| **MVVM** | CommunityToolkit.Mvvm | Source generators |
| **DI** | Microsoft.Extensions.DependencyInjection | Built-in DI |
| **Config** | YAML + JSON | Pattern management |

---

## âš ï¸ MANDATORY DEVELOPMENT PRINCIPLES - READ FIRST

### ğŸ—ï¸ BACKEND-FIRST, TEST-FIRST, UI-LAST (NON-NEGOTIABLE)

**ALL features MUST be built as testable backend components FIRST. UI is LAST.**

```
STRICT IMPLEMENTATION ORDER:
1. DOMAIN     â†’ Define entities, records, value objects
2. INTERFACE  â†’ Define small, focused interfaces (ISP)
3. TEST       â†’ Write tests for interface contracts (TDD RED)
4. SERVICE    â†’ Implement service to pass tests (TDD GREEN)
5. REFACTOR   â†’ Clean up while keeping tests green
6. UI         â†’ Wire up to existing tested components (LAST!)
```

**Backend-First Rules:**
- âš ï¸ **MUST**: ALL business logic lives in Application/Domain/Infrastructure layers
- âš ï¸ **MUST**: ViewModels ONLY orchestrate - NO business logic
- âš ï¸ **MUST**: Views ONLY bind - NO code-behind logic
- âš ï¸ **MUST**: Every feature works without UI (testable via services)
- âš ï¸ **MUST**: UI is pure "wiring" - connecting services to display

**Component Architecture:**
```csharp
// âŒ REJECT - Logic in ViewModel
public class MainWindowViewModel
{
    private void ProcessFiles()
    {
        foreach (var file in files)
        {
            var content = File.ReadAllText(file.Path);  // âŒ Logic here!
            var sanitized = Regex.Replace(content, pattern, alias);  // âŒ Logic here!
        }
    }
}

// âœ… REQUIRE - ViewModel delegates to services
public class MainWindowViewModel(
    IFileAggregationService fileService,    // Injected
    ISanitizationEngine sanitizationEngine) // Injected
{
    [RelayCommand]
    private async Task ProcessFilesAsync()
    {
        var files = await fileService.LoadDirectoryAsync(path);     // Delegate
        var result = sanitizationEngine.Sanitize(content, options); // Delegate
        // ViewModel only updates UI state
    }
}
```

**Feature Development Checklist:**
```
Before touching ANY UI code, verify:
â–¡ Domain model exists (entity/record)
â–¡ Interface defined (â‰¤5 methods, single purpose)
â–¡ Unit tests written and passing
â–¡ Service implemented and tested
â–¡ Integration test covers full workflow
THEN and ONLY THEN:
â–¡ Add ViewModel command/property
â–¡ Add XAML binding
```

---

### ğŸ§ª TEST-DRIVEN DEVELOPMENT (NON-NEGOTIABLE)

**ALL business logic MUST be validated through tests BEFORE implementation.**

```
STRICT TDD WORKFLOW:
1. RED    â†’ Write a failing test first
2. GREEN  â†’ Write minimum code to pass
3. REFACTOR â†’ Clean up while keeping tests green
```

**TDD Rules:**
- âš ï¸ **MUST**: Write tests BEFORE implementation code
- âš ï¸ **MUST**: Each interface method has corresponding tests
- âš ï¸ **MUST**: Tests exercise full business workflows
- âš ï¸ **MUST**: No implementation without passing tests first
- âš ï¸ **MUST**: Backend services fully tested before ViewModel created
- **Coverage targets**: 90% statements, 85% branches, 90% functions

**Test Naming Convention:**
```csharp
// Pattern: MethodName_Scenario_ExpectedBehavior
[Fact]
public async Task SanitizeAsync_WithDatabaseName_ReturnsAliasedValue()
{
    // Arrange
    var content = "Connect to ProductionDB";
    
    // Act  
    var result = await _sut.SanitizeAsync(content);
    
    // Assert
    result.SanitizedContent.Should().Be("Connect to DATABASE_0");
    result.WasSanitized.Should().BeTrue();
}

[Theory]
[InlineData("ProductionDB", true)]
[InlineData("localhost", false)]
[InlineData("192.168.1.1", true)]
public async Task SanitizeAsync_WithVariousInputs_DetectsCorrectly(
    string input, bool shouldSanitize)
{
    var result = await _sut.SanitizeAsync(input);
    result.WasSanitized.Should().Be(shouldSanitize);
}
```

### ğŸ”Œ INTERFACE SEGREGATION PRINCIPLE (NON-NEGOTIABLE)

**NOTHING should be created unless it's through a properly segregated interface.**

**ISP Rules:**
- âš ï¸ **MUST**: ALL business logic implements interfaces
- âš ï¸ **MUST**: NO direct class instantiation - only through interface contracts
- âš ï¸ **MUST**: Clients depend ONLY on methods they actually use
- âš ï¸ **MUST**: Interfaces are behavioral contracts, NOT implementation blueprints
- âš ï¸ **MUST**: Maximum 10 methods per interface - split if larger

**Interface Segregation Examples:**
```csharp
// âŒ REJECT - God interface
public interface ISanitizationService
{
    Task<string> SanitizeAsync(string content);
    Task<string> DesanitizeAsync(string content);
    void AddPattern(Pattern pattern);
    void RemovePattern(string name);
    IEnumerable<Pattern> GetPatterns();
    Task<AuditEntry> LogAsync(AuditEntry entry);
    IEnumerable<AuditEntry> GetAuditLog();
    // ... 20+ more methods
}

// âœ… REQUIRE - Segregated interfaces
public interface ISanitizationEngine
{
    Task<SanitizationResult> SanitizeAsync(string content, SanitizationOptions options);
}

public interface IDesanitizationEngine
{
    Task<DesanitizationResult> DesanitizeAsync(string content, IMappingSession session);
}

public interface IPatternRegistry
{
    void AddPattern(Pattern pattern);
    void RemovePattern(string name);
    IEnumerable<Pattern> GetPatterns();
}

public interface IAuditLogger
{
    Task LogAsync(AuditEntry entry);
    IAsyncEnumerable<AuditEntry> GetEntriesAsync(AuditQuery query);
}
```

### ğŸ¯ SIMPLICITY FIRST (CRITICAL)

**DO NOT OVERCOMPLICATE. Keep it simple, focused, and practical.**

- **KISS Principle**: Keep It Simple, Stupid
- **YAGNI**: You Aren't Gonna Need It - no premature abstractions
- **DRY**: Don't Repeat Yourself - but don't over-abstract
- **Avoid over-engineering** - resist architectural speculation
- **Prefer composition over inheritance**
- **No design patterns until absolutely necessary**
- **Always read README.md or root markdown to refresh context**

---

## .NET Best Practices (MANDATORY)

### C# Coding Standards

```csharp
// âœ… Use file-scoped namespaces
namespace ShieldPrompt.Sanitization.Engine;

// âœ… Use primary constructors for DI
public class SanitizationEngine(
    IPatternRegistry patternRegistry,
    IMappingSession session,
    ILogger<SanitizationEngine> logger) : ISanitizationEngine
{
    public async Task<SanitizationResult> SanitizeAsync(string content, SanitizationOptions options)
    {
        // Implementation
    }
}

// âœ… Prefer records for DTOs and immutable types
public record SanitizationResult(
    string SanitizedContent,
    bool WasSanitized,
    IReadOnlyList<SanitizationMatch> Matches);

public record SanitizationMatch(
    string Original,
    string Alias,
    PatternCategory Category,
    int StartIndex,
    int Length);

// âœ… Use init-only properties for configuration
public class SanitizationOptions
{
    public bool EnableInfrastructure { get; init; } = true;
    public bool EnablePII { get; init; } = true;
    public PolicyMode Mode { get; init; } = PolicyMode.SanitizedOnly;
}
```

### Naming Conventions

| Type | Convention | Example |
|------|------------|---------|
| **Interfaces** | `I` prefix + PascalCase | `ISanitizationEngine` |
| **Async methods** | `Async` suffix | `SanitizeAsync` |
| **Private fields** | `_camelCase` | `_patternRegistry` |
| **Constants** | PascalCase (not SCREAMING) | `MaxPatternLength` |
| **Extension methods** | `{Type}Extensions` | `StringExtensions` |
| **Test classes** | `{ClassUnderTest}Tests` | `SanitizationEngineTests` |

### Result Pattern (No Exceptions for Flow Control)

```csharp
// âœ… Use Result<T> for operations that can fail
public readonly record struct Result<T>
{
    public T? Value { get; }
    public string? Error { get; }
    public bool IsSuccess => Error is null;
    
    public static Result<T> Success(T value) => new() { Value = value };
    public static Result<T> Failure(string error) => new() { Error = error };
}

// Usage
public async Task<Result<SanitizationResult>> TrySanitizeAsync(string content)
{
    try
    {
        var result = await SanitizeAsync(content);
        return Result<SanitizationResult>.Success(result);
    }
    catch (PatternException ex)
    {
        return Result<SanitizationResult>.Failure(ex.Message);
    }
}
```

### Dependency Injection Pattern

```csharp
// âœ… Register services in extension methods
public static class ServiceCollectionExtensions
{
    public static IServiceCollection AddSanitizationServices(
        this IServiceCollection services)
    {
        // Singletons - shared across app
        services.AddSingleton<IPatternRegistry, PatternRegistry>();
        services.AddSingleton<IAliasGenerator, AliasGenerator>();
        
        // Scoped - per operation/session
        services.AddScoped<IMappingSession, MappingSession>();
        services.AddScoped<ISanitizationEngine, SanitizationEngine>();
        services.AddScoped<IDesanitizationEngine, DesanitizationEngine>();
        
        return services;
    }
}
```

### Async/Await Best Practices

```csharp
// âœ… Use ConfigureAwait(false) in library code
public async Task<string> ProcessAsync()
{
    var result = await _service.ExecuteAsync().ConfigureAwait(false);
    return await TransformAsync(result).ConfigureAwait(false);
}

// âœ… Use ValueTask for hot paths that often complete synchronously
public ValueTask<Pattern?> GetPatternAsync(string name)
{
    if (_cache.TryGetValue(name, out var pattern))
        return ValueTask.FromResult<Pattern?>(pattern);
    
    return new ValueTask<Pattern?>(LoadPatternAsync(name));
}

// âœ… Always honor CancellationToken
public async Task<SanitizationResult> SanitizeAsync(
    string content, 
    CancellationToken cancellationToken = default)
{
    cancellationToken.ThrowIfCancellationRequested();
    // ... implementation
}
```

### Memory Efficiency

```csharp
// âœ… Use Span<T> for string processing in hot paths
public static ReadOnlySpan<char> Sanitize(ReadOnlySpan<char> input)
{
    // Avoid allocations
}

// âœ… Use ArrayPool for temporary buffers
var buffer = ArrayPool<byte>.Shared.Rent(4096);
try
{
    // Use buffer
}
finally
{
    ArrayPool<byte>.Shared.Return(buffer);
}

// âœ… Use StringBuilder for concatenation
var sb = new StringBuilder(estimatedCapacity);
foreach (var item in items)
{
    sb.Append(item);
}
```

---

## Project Architecture

### Clean Architecture Layers

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                            ShieldPrompt Application                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚   Presentation   â”‚    â”‚    Application   â”‚    â”‚   Infrastructure â”‚      â”‚
â”‚  â”‚      Layer       â”‚    â”‚      Layer       â”‚    â”‚      Layer       â”‚      â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤      â”‚
â”‚  â”‚  â€¢ Views (AXAML) â”‚    â”‚  â€¢ Services      â”‚    â”‚  â€¢ FileSystem    â”‚      â”‚
â”‚  â”‚  â€¢ ViewModels    â”‚â—„â”€â”€â–ºâ”‚  â€¢ Interfaces    â”‚â—„â”€â”€â–ºâ”‚  â€¢ Clipboard     â”‚      â”‚
â”‚  â”‚  â€¢ Converters    â”‚    â”‚  â€¢ DTOs          â”‚    â”‚  â€¢ Settings      â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚                                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚                           Domain Layer                                â”‚  â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚
â”‚  â”‚  â€¢ Entities        â€¢ Value Objects       â€¢ Enums                     â”‚  â”‚
â”‚  â”‚  â€¢ Domain Events   â€¢ Domain Services     â€¢ Specifications            â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Layer Dependency Rules

| Layer | Can Reference | Cannot Reference |
|-------|---------------|------------------|
| **Domain** | Nothing (pure) | Application, Infrastructure, Presentation |
| **Application** | Domain | Infrastructure, Presentation |
| **Infrastructure** | Domain, Application | Presentation |
| **Presentation** | Domain, Application | Infrastructure (via DI only) |

### Component Responsibility Matrix (STRICT)

| Component | ALLOWED | FORBIDDEN |
|-----------|---------|-----------|
| **Domain Entities** | Properties, validation, factory methods | IO, async, external calls |
| **Domain Records** | Immutable data transfer | Behavior, logic |
| **Application Services** | Business logic, orchestration | UI concerns, View references |
| **Infrastructure Services** | File IO, HTTP, persistence | Business logic |
| **ViewModels** | Command handlers, property binding, service delegation | Business logic, direct IO |
| **Views (XAML)** | Data binding, layout, styling | Code-behind logic, service calls |

### What Goes Where

```csharp
// Domain Layer - Pure business concepts
public record FileOperation(FileOperationType Type, string Path, string? Content);
public enum FileOperationType { Create, Update, Delete }

// Application Layer - Business logic services
public interface IFileWriterService { Task<Result> ApplyAsync(FileOperation op); }
public class FileWriterService : IFileWriterService { /* implementation */ }

// Infrastructure Layer - External concerns
public class JsonSettingsRepository : ISettingsRepository { /* file IO */ }

// Presentation Layer - UI wiring ONLY
public partial class MainWindowViewModel : ViewModelBase
{
    [RelayCommand]
    private async Task ApplyChangesAsync()
    {
        // âœ… Delegate to service - NO logic here
        var result = await _fileWriter.ApplyAsync(operation);
        StatusText = result.IsSuccess ? "Done" : result.Error;
    }
}
```

### Project Structure

```
ShieldPrompt/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ ShieldPrompt.App/                  # Entry point, DI setup
â”‚   â”œâ”€â”€ ShieldPrompt.Presentation/         # UI (Views, ViewModels)
â”‚   â”œâ”€â”€ ShieldPrompt.Application/          # Business logic services
â”‚   â”œâ”€â”€ ShieldPrompt.Domain/               # Pure domain models
â”‚   â”œâ”€â”€ ShieldPrompt.Infrastructure/       # External concerns
â”‚   â””â”€â”€ ShieldPrompt.Sanitization/         # Sanitization engine
â”‚
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ ShieldPrompt.Tests.Unit/           # Unit tests (fast, isolated)
â”‚   â”œâ”€â”€ ShieldPrompt.Tests.Integration/    # Integration tests
â”‚   â””â”€â”€ ShieldPrompt.Tests.Architecture/   # Architecture compliance
â”‚
â””â”€â”€ config/
    â”œâ”€â”€ default-patterns.yaml              # Built-in sanitization patterns
    â””â”€â”€ model-profiles.json                # AI model configurations
```

---

## SIZE THRESHOLDS (.NET)

| Metric | Limit | Rationale |
|--------|-------|-----------|
| **File Length** | 500 lines max | C# files include XML docs |
| **Method** | 50 lines max | Single responsibility |
| **Class** | 400 lines max | Domain-focused |
| **Interface** | 10 methods max | Apply ISP |
| **Constructor Parameters** | 7 max | Use options pattern |
| **Cyclomatic Complexity** | 10 max | Per method |
| **Nesting Depth** | 4 levels max | Use guard clauses |

### When Limits Are Exceeded

```
If Class > 400 lines:
  â†’ Split by responsibility
  â†’ Apply Single Responsibility Principle
  â†’ Extract helper classes

If Interface > 10 methods:
  â†’ Apply Interface Segregation
  â†’ Create focused interfaces (IReader, IWriter)
  â†’ Consider Command/Query separation

If Method > 50 lines:
  â†’ Extract private methods
  â†’ Use early returns / guard clauses
  â†’ Consider strategy pattern for complex logic
```

---

## Testing Standards

### Test Project Structure

```csharp
// Test fixture with real implementations (prefer over mocks)
public class SanitizationEngineTests
{
    private readonly ISanitizationEngine _sut;
    private readonly InMemoryPatternRegistry _patternRegistry;
    private readonly InMemoryMappingSession _session;
    
    public SanitizationEngineTests()
    {
        _patternRegistry = new InMemoryPatternRegistry();
        _patternRegistry.AddPattern(new Pattern("Database", @"(Prod|Dev).*DB", PatternCategory.Database));
        
        _session = new InMemoryMappingSession();
        
        _sut = new SanitizationEngine(_patternRegistry, _session, NullLogger<SanitizationEngine>.Instance);
    }
    
    [Fact]
    public async Task SanitizeAsync_WithServerName_ReturnsAlias()
    {
        // Arrange
        var content = "Query ProductionDB";
        
        // Act
        var result = await _sut.SanitizeAsync(content, new SanitizationOptions());
        
        // Assert
        result.WasSanitized.Should().BeTrue();
        result.SanitizedContent.Should().Be("Query DATABASE_0");
        result.Matches.Should().ContainSingle()
            .Which.Original.Should().Be("ProductionDB");
    }
}
```

### Real Implementations Over Mocks (CRITICAL)

**NEVER use mocks when a real local implementation is feasible.**

```csharp
// âŒ BAD - Mock that doesn't test real behavior
var mockRegistry = Substitute.For<IPatternRegistry>();
mockRegistry.GetPatterns().Returns(new[] { testPattern });

// âœ… GOOD - Real in-memory implementation
var registry = new InMemoryPatternRegistry();
registry.AddPattern(testPattern);
// Tests actual pattern matching behavior
```

### When Mocks Are Acceptable (RARE)

- External paid APIs with no free tier
- Hardware interfaces not available locally
- Third-party services with complex authentication
- BUT EVEN THEN: Prefer stub services over pure mocks

---

## Security-First Development (CRITICAL FOR THIS PROJECT)

### Fail-Secure Design

```csharp
// âœ… Always fail secure - block on error, never leak
public async Task<SanitizationResult> SanitizeAsync(string content)
{
    try
    {
        return await ProcessSanitizationAsync(content);
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "Sanitization failed - blocking content");
        
        // FAIL SECURE: Return blocked result, don't pass through original
        return new SanitizationResult(
            SanitizedContent: "[CONTENT BLOCKED - SANITIZATION ERROR]",
            WasSanitized: true,
            Matches: Array.Empty<SanitizationMatch>(),
            Error: "Sanitization failed - content blocked for safety");
    }
}
```

### Never Log Sensitive Data

```csharp
// âœ… CORRECT - Log metadata, not content
_logger.LogInformation(
    "Sanitized content: {MatchCount} sensitive values found in {Category}",
    result.Matches.Count,
    result.Matches.FirstOrDefault()?.Category);

// âŒ NEVER DO THIS
_logger.LogDebug("Original content: {Content}", originalContent);
_logger.LogDebug("Mapping: {Original} -> {Alias}", mapping.Original, mapping.Alias);
```

### Secure Session Management

```csharp
// âœ… Sessions in memory only, cleared on exit
public class MappingSession : IMappingSession, IDisposable
{
    private readonly Dictionary<string, string> _mappings = new();
    private readonly object _lock = new();
    
    public void Dispose()
    {
        lock (_lock)
        {
            // Secure clear - overwrite before clearing
            foreach (var key in _mappings.Keys.ToList())
            {
                _mappings[key] = new string('0', _mappings[key].Length);
            }
            _mappings.Clear();
        }
    }
}
```

---

## What NOT to Do

| âŒ Don't | âœ… Do Instead |
|---------|---------------|
| Use `dynamic` or `var` when type is unclear | Use explicit types |
| Catch `Exception` without re-throwing or logging | Handle specific exceptions |
| Use `Task.Result` or `Task.Wait()` | Use `await` (prevents deadlocks) |
| Log sensitive data (passwords, tokens, PII) | Log metadata only |
| Use string concatenation for SQL | Use parameterized queries |
| Ignore `CancellationToken` parameters | Always honor cancellation |
| Create new `HttpClient` instances directly | Use `IHttpClientFactory` |
| Use `Thread.Sleep` | Use `Task.Delay` |
| Suppress warnings without documented reason | Fix the warning or document why |
| Use `any` equivalent (object casting) | Use proper generics |
| Write implementation before tests | TDD: test first, always |
| Create god interfaces (>10 methods) | Apply ISP, split interfaces |

---

## Safety Rails

### General Rules
- Never delete/refactor/optimize/remove files without approval
- Preserve comments & existing style
- Assume code has purpose
- Present simpler alternative with confidence (1â€“10) before edits

### Security-Specific
- Never expose original sensitive values in logs, errors, or UI
- Always validate input at boundaries
- Fail secure - block rather than pass through
- Clear sensitive data from memory when no longer needed

---

## Response Format

```
[code]
Edge cases handled: [list]
Tests written: [list test methods]
Security considerations: [list]
Potential refactors (not implemented): [list]
```

---

## Self-Check Before Submitting

### Architecture Compliance (CHECK FIRST)
- [ ] Feature implemented as backend service FIRST
- [ ] Service has interface (ISP: â‰¤5 methods)
- [ ] Unit tests exist and pass for service
- [ ] ViewModel ONLY delegates to services (no logic)
- [ ] View ONLY binds (no code-behind)

### TDD Compliance
- [ ] Tests written FIRST (TDD RED phase)
- [ ] Tests pass (TDD GREEN phase)
- [ ] Code refactored with tests still green

### Code Quality
- [ ] All interfaces segregated (<10 methods)
- [ ] No `any` types or unsafe casts
- [ ] Async methods use CancellationToken
- [ ] No sensitive data in logs
- [ ] Fail-secure error handling
- [ ] Classes under 400 lines
- [ ] Methods under 50 lines
- [ ] Constructor parameters â‰¤ 7
- [ ] Uses GlobalUsings.* for common imports
- [ ] XML documentation on public APIs
- [ ] STRICT mode honored

### Before UI Work
- [ ] Backend service fully tested
- [ ] Service works without UI (verified via tests)
- [ ] Interface is stable (won't change during UI work)
- [ ] ViewModel is thin (delegation only)

---

## Shell Commands

```bash
/bin/zsh -i -c 'source ~/.zshrc && <cmd>'
```

---

## Key Commands

```bash
# Build
dotnet build

# Run tests (TDD - run often!)
dotnet test
dotnet test --filter "FullyQualifiedName~SanitizationEngine"
dotnet test --collect:"XPlat Code Coverage"

# Run application
dotnet run --project src/ShieldPrompt.App

# Watch mode (development)
dotnet watch run --project src/ShieldPrompt.App

# Format code
dotnet format

# Analyze code
dotnet build /p:TreatWarningsAsErrors=true
```

---

## Reference Documents

When explaining decisions, reference:
1. **SPECIFICATION.md** - Full product specification
2. **README.md** - Project overview
3. **architecture-checklist.md** - If present, follow strictly
4. **docs/implementation/** - Phase specifications

---

## Implementation Workflow (MANDATORY)

### Adding a New Feature

```
STEP 1: DOMAIN (no tests needed)
â”œâ”€â”€ Create entity/record in ShieldPrompt.Domain
â”œâ”€â”€ Define enums if needed
â””â”€â”€ Commit: "feat(domain): Add XYZ entity"

STEP 2: INTERFACE (no tests needed)
â”œâ”€â”€ Create interface in ShieldPrompt.Application/Interfaces
â”œâ”€â”€ Apply ISP: â‰¤5 methods per interface
â””â”€â”€ Commit: "feat(app): Add IXYZService interface"

STEP 3: TESTS (TDD RED)
â”œâ”€â”€ Create test class in ShieldPrompt.Tests.Unit
â”œâ”€â”€ Write tests for EVERY interface method
â”œâ”€â”€ Tests should FAIL (no implementation yet)
â””â”€â”€ Commit: "test: Add XYZService tests (red)"

STEP 4: SERVICE (TDD GREEN)
â”œâ”€â”€ Implement service in ShieldPrompt.Application/Services
â”œâ”€â”€ Run tests until ALL pass
â”œâ”€â”€ Refactor while keeping tests green
â””â”€â”€ Commit: "feat(app): Implement XYZService (green)"

STEP 5: INFRASTRUCTURE (if needed)
â”œâ”€â”€ Implement repository/external service
â”œâ”€â”€ Add integration tests
â””â”€â”€ Commit: "feat(infra): Add XYZ repository"

STEP 6: VIEWMODEL (UI wiring)
â”œâ”€â”€ Add command/properties to ViewModel
â”œâ”€â”€ Inject service via constructor
â”œâ”€â”€ Delegate ALL logic to service
â””â”€â”€ Commit: "feat(vm): Wire up XYZ to ViewModel"

STEP 7: VIEW (UI binding)
â”œâ”€â”€ Add XAML bindings
â”œâ”€â”€ NO code-behind logic
â””â”€â”€ Commit: "feat(view): Add XYZ UI"
```

### Feature Implementation Order

When implementing a multi-part feature:

```
Example: "Apply Mode Enhancement"

1. FileOperation record          â†’ Domain
2. IFileOperationPreview         â†’ Interface (preview diff)
3. IFileOperationApplier         â†’ Interface (apply changes)
4. FileOperationPreviewTests     â†’ Tests
5. FileOperationApplierTests     â†’ Tests
6. FileOperationPreviewService   â†’ Service
7. FileOperationApplierService   â†’ Service
8. ApplyDashboardViewModel       â†’ ViewModel (LAST)
9. ApplyDashboard.axaml          â†’ View (VERY LAST)

âš ï¸ NEVER skip to step 8 or 9 without completing 1-7!
```

---

**Remember: This is a SECURITY-FOCUSED application. When in doubt, fail secure.**
**Remember: BACKEND-FIRST, TEST-FIRST, UI-LAST. No exceptions.**

**Last Updated:** January 14, 2026  
**Status:** ACTIVE - ENFORCED

